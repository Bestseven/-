### 术语

- CAP系统经典理论

一个分布式系统不可能同时满足C一致性，A可用性和P分区容错性这三个基本需求，最多只能同时满足其中的两项。

> 一个是一致性状态；有限时间内的返回结果是衡量和永兴的额标准；**分布式环境下，一部分网络故障依然能保证对外提供CA的服务。**
>
> 因此，P是一个必须要面对和解决的问题。



![img](https://cdn.nlark.com/yuque/__mermaid_v3/a7945375c42bd73f60687d83a8d0f7c9.svg)

- 事务

> 事务是由一系列对系统数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务具有四个特性，原子性、一致性、隔离性、持久性，即ACID。



![img](https://cdn.nlark.com/yuque/__mermaid_v3/03bc319e7d50d16fba1030fa25943706.svg)



## 1.一致性协议

- 2PC
- 3PC



每一个机器节点虽然能够明确知道自己在进行事物操作过程中的结果是成功或者失败，但是却无法获取到其他分布式节点的操作结果。因此在这个过程中，就需要引入一个协调者的组件，来统一调度，所有的分布式节点的执行逻辑。



### 1.1 2PC



## 一致性协议



2 PC :强一致性算法,绝大多数关系型数据库都在使用二阶段提交协议



![img](https://cdn.nlark.com/yuque/__mermaid_v3/ce076aefdaee589596c9f7a349a080e9.svg)



**问题**



进行二阶段提交的过程中，可能会受到有一些**同步阻塞**，**单点问题**和**数据不一致**的问题。**太过保守**，没有容错机制。



### 1.2 3PC



简单说明：



3PC是二阶段的改良版将二阶段提交的提交事物请求的过程一分为二。



优势是最大程度上解决了同步阻塞问题，但是其他问题依然存在。



### 1.3 Paxos算法



Paxos是一种提高分布式系统容错性的一致性算法。“过半”概念。



## 2. Zookeeper是什么



是一个开放源代码的分布式协调服务。是一个**分布式数据一致性**解决方案；分布式应用程序，基于它可以实现数据发布/订阅，负载均衡，命名服务，分布式协调/通知，集群管理，Master选举，分布式锁和分布式队列等功能，**ZooKeeper可以保证分布式一致性特性**。



特点：

- 顺序一致性
- 原子性
- 单一视图
  无论客户端连接的哪个ZooKeeper服务器，其看到的服务器数据模型都是一致的。
- 可靠性
  一旦服务端成功应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更会被一直保留下来。除非有另一个事务对其进行了变更。
- 实时性



Zookeeper设计目标：



- 简单数据模型
- 构建集群，过半及其工作正常服务
- 顺序访问，对于客户端的每个更新请求，zk都会分配一个全局唯一递增编号。
- 高性能，全量数据存储在内存中。



### 2.1 Zookeeper的基本概念



- 集群角色，Leader、Follower、Observer
- 会话（Session），客户端和服务端之间的连接是一个长连接。通过心跳检测与服务端保持会话；接受服务器Watch事件通知。
- 数据节点（Znode），Zookeeper所有的数据存储在内存中，数据模型是一棵树（Znode Tree），由斜杠分割的路径就是一个Znode，例如*/foo/path1*；持久节点，临时节点。节点属性（sequential）
- 版本，Znode中有一个Stat数据结构，记录了Zonde的数据版本
- Watcher，（事件监听器）该机制是实现分布式协调服务的重要特性，**Zookeeper允许用户在****指定节点注册一些Watcher****，并在一些特定事件出发时候，zk服务端会将事件通知到感兴趣的客户端上。**
- ACL，zookeeper权限控制

- - create,创建子节点权限
- read获取节点数据和子节点列表权限
- write更新节点数据权限
- delete子节点权限
- admin设置节点acl权限



![img](https://cdn.nlark.com/yuque/__mermaid_v3/e2b84d2a5749c4352313327c6ab43812.svg)

### 2.2 ZAB协议



原子消息广播协议，是作为zk数据一致性的核心算法。



*ZooKeeper使用一个**单一的主进程来接受并处理客户端的所有事物请求**，并采用ZAB的原子广播协议，将**服务器数据的状态变更以事务Proposal的形式广播到所有副本进程**上去，ZAB协议的这个主备模型架构保证了同一时刻集群中只能有一个主进程来广播服务器的状态变更，因此可以很好的处理客户端大量的并发请求*



![img](https://cdn.nlark.com/yuque/__mermaid_v3/db16d95be20c6b1ca9157931e94560b0.svg)

#### 2.2.1 协议核心



**所有的事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被成为Leader服务器，余下的服务器成为Follower服务器。Leader服务器负责将一个客户端事务转化成一个事务Proposal（提议）并将该Proposal分发给集群中所有的Follower服务器。 之后Leader服务器需要等待所有Follower服务器的反馈，超半数服务器进行了正确的反馈之后，Leader服务器会再次向所有的Folloer服务器分发Commit消息，要求其将前一个Proposal进行提交。**



#### 2.2.2 具体内容



ZAB协议两种基本模式：**崩溃恢复和消息传播**



当Leader服务器出现网络中断，崩溃退出与重启等异常情况下，就会进入恢复模式选举产生新的Leader服务器。当选举产生新的服务器之后，同时集群中已经有过半机器与该leader服务器完成了 状态同步之后，ZAb协议就会推出恢复模式。*状态同步是指数据同步，用来保证集群中存在过半及其能够和Leader服务器数据状态保持一致*。



消息广播模式，我们知道zk服务器中只存在一个Leader服务器来进行事务请求的处理。Leader服务器在接收到事务请求后，生成对应的事务提议并发起一轮广播协议；如果集群中的其他机器接受到客户端的事务请求，那么 这些非Leader服务器会首先将这个事务请求转发给Leader服务器。



在Leader服务器出现宕机后，那么**在重新开始新一轮的ZAB事务操作之前，所有进程首先使用崩溃恢复协议，来使彼此达到一个一致的状态**，于是整个ZAB流程从消息广播模式进入崩溃恢复模式。



- 消息广播



ZAB协议的消息广播过程使用的是一个原子广播协议，类似于一个二阶段提交过程。



消息广播过程中，首先会对事务分配一个全局单调递增的唯一ID，即事务ID（ZXID），然后对这个事务生成对应的Proposal来进行广播。



ZAB协议需要保证每一个消息严格的因果关系，因此必须将每一个事务Proposal按照ZXID的先后顺序进行排序和处理。



- 崩溃恢复



ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交。



**问题**：假设一个事务在Leader服务器上被提交了，并且已经得到过半Follower服务器的Ack反馈，但是在它将Commit消息发送给所有的Follower机器之前，Leader服务器挂了，针对这种情况，ZAB协议就需要确保事务Proposal2最终能够在所有的服务器上都被提交成功，否则将出现不一致，相反在崩溃恢复过程中出现一个需要被丢弃的提议，那么在恢复结束后需要跳过该事务。



**ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交；ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务**



在此，这个问题上，针对这种特殊情况，**如果选举出来的Leader服务器拥有集群中所有机器最高编号事务Proposal（zxid）那么就可以保证这个新选举出来的Leader一定具有所有已经提交的提案**。更为重要的是，*如果具有最高编号事务的机器称为Leader，就可以省去Leader服务器检查Proposal的提交和丢弃工作的这一步了*。



- 数据同步



Leader服务器和follower服务器的数据需要保持同步。Leader服务器需要确保所有follower服务器正确已经提交了的事务Proposal应用到内存数据库中。在此之后，Leader服务器就会将该Follower服务器加入到真正可用的Follower列表中。



![img](https://cdn.nlark.com/yuque/__mermaid_v3/67d3a99486a66c759674b77e7a23065d.svg)



问题：如何处理那些需要被丢弃的事务Proposal的？



**事务编号zxid**，是一个64位的数字，低32位数一个简单单调递增计数器，每收到一个事务请求就会+1。高32位代表了Leader周期epoch的编号，这个编号是由选举产生leader服务器时候，就会从此leader中zxid解析出对应epoch然后对其进行+1。以此作为新epoch编号，低32位从0开始生成新zxid。



因此根据zxid就可以知道，上一个Leader周期尚未提交的事务Prososal的服务器启动时肯定无法成为Leader。

![img](https://cdn.nlark.com/yuque/__mermaid_v3/e8288b16ceb21f4cd1230498cb43a686.svg)

### 2.3 Zookeeper 集群搭建



- 集群模式

1. 1. 准备java运行环境
2. 下载zk安装包
3. 配置zoo.cfg

> - 说明：server.id = host:port:port
    >   id是用于标识该机器在集群中的机器序号
> - 在zookeeper中，集群中所有zoo.cfg文件内容都应该是一致的，因此最好使用svn或者git把此文件管理起来

```
tickTime=2000
initLimit=10
syncLimit=5
dataDir=/opt/soft/zookeeper/zk1/data
clientPort=2181
server.1=127.0.0.1:2888:3888
server.2=127.0.0.1:2888:2888
server.3=127.0.0.1:2888:2888
```

1. 1. 创建myid文件
2. 按照此步骤，在其他机器上都配置上zoo.cfg和myid文件
3. 启动服务

- 单机模式配置

```
tickTime=2000
initLimit=10
syncLimit=5
dataDir=/opt/soft/zookeeper/zk1/data
clientPort=2181
server.1=127.0.0.1:2281:3881
```

- 伪集群配置

```
tickTime=2000
initLimit=10
syncLimit=5
dataDir=/opt/soft/zookeeper/zk1/data
clientPort=2181
server.1=127.0.0.1:2881:3881
server.2=127.0.0.1:2882:2882
server.3=127.0.0.1:2883:2883
```



## 3. Zookeeper 应用场景



### 1. 数据发布/订阅



Publish/Subscribe系统，即配置中心，发布者将数据发布到ZooKeeper的一个或一些列节点上，供订阅者进行数据订阅。实现配置信息的集中式管理和数据的动态更新。



配置信息在ZK上存放管理，启动时候客户端主动到ZK服务器上进行配置信息获取，同时在指定节点上注册监听，这样以来，一旦配置信息发生变化，服务端会实时通知所有订阅的客户端，从而达到实时获取最新配置信息的目的。



数据库切换应用场景



我们将数据初始化存储在ZK上，选择一个节点用于存储如*/app1/database_config*



我们将需要管理的配置信息写入数据节点中



```
#配置清单
dbcp.driverClassName=com.mysql.jdbc.Driver
dbcp.username=xiaozhi
dbcp.password=123456
···
```



集群中每台机器在初始化阶段会首先从上面的zk配置节点上获取数据库信息，同时在该配置节点上注册一个数据变更的Watcher，一旦节点数据变更，所有订阅的客户端都能够获取数据变更通知。



### 2. 负载均衡



提高优化资源使用，最大吞吐率，保证系统可用性。



### 3.Master选举



集群中所有机器都执行一个计算逻辑会非常耗费资源，只让其中一台处理数据计算，然后共享给整个集群其他客户端，可以大量减少劳动，提高性能。



广告投放模型：



Client集群每天定时通过ZK实现Master选举，然后进行海量数据处理，获取一个数据结果，放在一个内存/数据库，同时，Master还需要通知集群中其他所有客户端从这个内存/数据库共享计算结果。



Master选举过程：



利用关系型数据库中的主键特性实现，集群中所有机器都向数据库插入一条相同主键ID的记录，数据库会帮助我们自动进行主键冲突检查，也就是说只有一台机器能够成功，那么该机器成为Master。



### 4分布式锁



目前绝大多数大型分布式系统的性能瓶颈都集中在数据库操作上。



分布式锁是控制分布式系统之间同步访问共享资源的一种方式，通过一些互斥手段来防止彼此之间的干扰，以保证一致性。



## 4.技术内幕



### 1.系统模型



- 树，类似于Unix文件系统，数据节点Znode是ZK中数据的最小单元，每个Znode上都可以保存数据和挂载子节点。
- **事务ID**，**在ZK中，事务时指能够改变ZooKeeper服务器状态的操作**一般包括数据节点创建删除，节点内容更新和客户端会话创建与失效。每一个事务请求，zk都会分配一个zxid。



### 2.节点特性



节点的生命周期取决于节点类型。



- 持久节点
- 临时节点
- 顺序节点



持久节点时常见的节点类型，被创建后一直存在，知道删除操作清除节点。



节点顺序节点是在持久/临时特性上增加sequential，父节点会维护子节点的顺序，就是给节点名后加一个数字后缀。



临时节点是生命周期和客户端会话绑定一起，如果客户端会话失效，节点就会被自动清理；另外zk规定临时节点只能作为叶子节点。



状态信息Stat，即zk节点信息



### 3. Leader选举概述



#### 服务器启动时期Leader选举



1. 每个Server发出一个投票
2. 接受各自服务器投票
3. 处理投票
4. 统计投票
5. 改变服务器状态



对于服务器，每次投票的基本元素包括服务器的myid和ZXID，用（myid，zxid）形式表示，因此一开始Server1为（1，0）Server2为（2，0）然后各自将这个投票发给集群中其他所有机器。



接受到投票后，验证有效性，然后和自己的投票PK。



- 优先检查ZXID，ZXID大则优先作为Leader
- ZXID相同则比较myid，myid大则作为Leader



于是Server1收到投票后会改投Server2，对于三台集群而言，符合过半要求，当Server1，2都收到投票信息，即已认为选出了Leader。



#### 服务器运行期间Leader选举

![img](https://cdn.nlark.com/yuque/__mermaid_v3/70d23a98258b80f0c3a21e121edb070c.svg)



1. 变更状态
2. 每个Server发出选票
3. 接受选票
4. 处理投票
5. 统计投票
6. 改变服务器状态



Leader挂了之后，剩余服务器更改服务器状态变更为LOOKING，进入选举流程，运行期间的zxid可能不同比如，Server1为（1，123），Server3为（3，122），那么显然Server1成为Leader。



> 术语解释
>
> SID：服务器ID即myid值
>
> ZXID：事务ID
>
> Vote：投票
>
> Quorum：过半数器数



### 4. 服务器角色介绍



**Leader**



- 事务请求的唯一调度和处理者，保证集群事务处理的顺序性
- 集群内部各服务器的调度者



为了保持集群内部实时通信，Leader服务器会和每一个Followe/Observer服务器建立一个TCP长链接。



**Follower**



- 处理客户端非事务请求，转发事务请求给Leader服务器
- 参与事务请求Proposal的投票
- 参与Leader选举投票



**Observer**：和Follower一样，但是不参与任何形式投票



**Proposal流程**



即投票统计过程



1. 发起投票
2. 生成提议Proposal对象
3. 广播提议
4. 收集投票
5. 将请求放入toBeApplied队列
6. 广播COMMIT消息



**Commit流程**



1. 将请求交付CommitProcessor处理器
2. 处理queuedRequests队列请求
3. 标记nextPending
4. 等待Proposal投票
5. 投票通过
6. 提交请求



然后进行**事务应用**和**会话响应**完成交易。



**事务请求转发**



所有非Leader服务器如果收到了来自客户端的事务请求，那么必须将其转发给Leader服务器来处理。
